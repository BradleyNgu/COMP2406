COMP 2406 2024F Assignment 1
Name: Bradley Nguyen
Student ID:101270011

1. I first began by reviewing the simpleserver2.js file. Here, I was looking for the portion of code responsible for reading and serving files. Next, I located the fileData function which 
reads the requested file with the line contents = await Deno.readFile("./www" + path_);. Here, I realized that the path is being prefixed with ./www which shows that this is the directory 
being used to serve content. I can verify this by creating a basic index.html file in the designated directory and started the server. Here by accessing http://localhost:8000, 
it shows that it correctly served the file from this directory.


2. I first looked at the MIMEtype function, which is responsible for determining the MIME type of the files served by the server. Here, I noticed that the MIME types for common file 
extensions were listed, but there was no entry for .pdf. To confirm, I placed a .pdf file called sample.pdf in the www directory and attempted to access it through the browser.
By doing this, the server returned the file, but the browser indicated that the MIME type was 200 GET application/octet-stream/sample.pdf, which is a generic MIME type and not specific to PDF files.


3. Here, I modified the MIMEtype function to be asynchronous by assigning the async keyword. Next I encountered errors in the fileData function becasue MIMEtype was now returning a 
Promise instead of a string. The function call needed to be awaited to retrieve the actual value. To fix this, I updated the fileData function by adding await before the MIMEtype call. 
This ensures that the MIME type was correctly retrieved before being used.


4a. First I looked at the handler function where requests are processed. Next, I decided to add a check for the HTTP method at the beginning of the function. 
If the method was not GET, I would return a 501 not Implemented response. Next, I implement this by adding the following code to the handler function:
     if (req.method !== "GET") {
        return new Response("Method not implemented", { status: 501 });
    }
All in all, I modified the handler function to check the request method and return a 501 Not Implemented response for non-GET requests.

4b. After implementing the check for the GET method, I wanted to be sure that only GET requests were handled. Here, I used curl to send both GET and POST requests to the server. Here I saw 
that the GET requests were served normally, while the POST requests returned the "Method not implemented" message with the status code 501. Here, no major issues arose.


5a. First, I identified that the template_notFound function was hardcoded in the source. Next, I created a 404.html file in the www directory and modified the fileData function so that it loads the 404.html 
file if the requested file is not found. 
async function fileData(path) {
    var contents, status, contentType;
    
    try {
        contents = await Deno.readFile("./www" + path);  // Tries to read the requested file
        status = status_OK;
        contentType = MIMEtype(path);
    } catch (e) {
        contents = await Deno.readFile("./www/404.html");  // Loads 404.html if the requested file is not found
        status = status_NOT_FOUND;
        contentType = "text/html";
    }
    
    return { contents, status, contentType };
}

5b. I believe my solution is correct as it follows the requirements of loading the "Page not found" template from an external file rather than hardcoding it. I tested this by accessing non-existent URLs, and 
the server returned the contents of the 404.html file.

5c. A big issue that I made was forgetting to await the Deno.readFile() call when loading 404.html. Because of this, it retuned a Promise instead of the actual file contents which broke the response.

6a. First, I noticed that the code was using the URL object to extract the pathname from the URL. Since the question is telling me not to use a URL object, I opted to use regular expressions and Javascript's string manipulation (split in this case) to get the path.
replace(/^https?:\/\/[^\/]+/, '') is responsible for removing the http:// or https://, the host name, and the port. ^ means the start of the string, https? matches either http or https, 
and :// matches the literal :// that follows http or https. [^\/]+ is a character class that means "any character that is not a // + means "one or more occurences. Here, this part 
matches the domain name (in our case localhost), up to the first / after the domain name. The replace() replaces the matched portion with an empty string. Split('?') splits the string at 
the ? character into an array. Here the first element will be the part before the ? and the second element will be the query string. split('#')[0] removes any fragment identifier from 
the URL, which starts with #. Like split('?')[0], it splits the string at the # into an array and the first element [0] will be the part before the # and the second element will be the fragment. 
    
    var origpath = req.url.replace(/^https?:\/\/[^\/]+/, '').split('?')[0].split('#')[0];
    console.log("Extracted Path:", origpath);  // Log the extracted path to check


6b. I used ChatGPT model 4o to familarize myself with regular expressions and what it does (especially since I was having trouble removing the http://localhost:8000), then used W3schools to understand how to use split and replace.

6c. I started the simpleserve2 by running deno run --allow-net --allow-read simpleserver2.js. Here I accessed various URLs in the browser and check that the correct file was being served. Next, I used curl to send requests with URLs containing query parameters and fragments to ensure they were being ignored. Here the correct path was extracted as and ignored the query and fragment.

6d. First, I thought I could solely use split to get rid of the fragments and that did work. But when it came to deleting http://localhost:8000, I had trouble grasping how to do such a task. 
Here, I looked on forums on how to solve the problem, and it all pointed to using regular expressions. Here, I used ChatGPT to build my solution as I asked it how to use Regex to delete the 
http://localhost:8000 since I was often left with http://localhost:8000/index.html when extracting. 